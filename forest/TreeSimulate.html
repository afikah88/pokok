<!DOCTYPE html>
<html>
<head>
    <title>Tree Distribution Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="styles.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
    <div class="container">
        <h1>Forest Tree Map with Cut Angles</h1>
        <div id="map"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Initialize map
        var map = L.map('map', {
            zoomControl: true,
            minZoom: 5,
            maxZoom: 22
        }).setView([3.97627092663759, 102.24896927028513], 18);

        // Create background pane
        map.createPane('background');
        map.getPane('background').style.zIndex = 1;

        // Add tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 22,
            opacity: 0.15,
            pane: 'background',
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        // Add green background
        function updateBackgroundColor() {
            const bounds = map.getBounds();
            const greenBackground = L.rectangle(bounds, {
                color: '#90EE90',
                weight: 0,
                fillOpacity: 0.8,
                pane: 'background'
            }).addTo(map);

            map.on('moveend', function() {
                const newBounds = map.getBounds();
                greenBackground.setBounds(newBounds);
            });
        }

        // Define status colors
        const statusColors = {
            'keep': '#FFCCEA',
            'victim_crown': '#FFB38E',
            'victim_stem': '#DE8F5F',
            'cut': '#CDC1FF'
        };

        // Create legend
        const legend = L.control({position: 'bottomright'});
        legend.onAdd = function(map) {
            const div = L.DomUtil.create('div', 'legend');
            div.innerHTML = '<h4>Tree Status</h4>';
            
            for (const status in statusColors) {
                const displayStatus = status.replace('_', ' ')
                    .split(' ')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');
                div.innerHTML += `
                    <div class="legend-item">
                        <span class="color-box" style="background: ${statusColors[status]}"></span>
                        ${displayStatus}
                    </div>`;
            }
            return div;
        };
        legend.addTo(map);

        // Create tree icon
        function createTreeIcon(status, size = 24) {
            const color = statusColors[status] || '#3388ff';
            const svgSize = size;
            const treeSvg = `
                <svg viewBox="0 0 24 24" width="${svgSize}" height="${svgSize}">
                    <path d="M12 2L5 12H8V20H16V12H19L12 2Z" 
                          fill="${color}" 
                          stroke="black" 
                          stroke-width="1"/>
                </svg>`;

            return L.divIcon({
                html: treeSvg,
                className: 'tree-icon',
                iconSize: [svgSize, svgSize],
                iconAnchor: [svgSize/2, svgSize]
            });
        }

        // Draw falling line with arrow
        function drawFallingLine(map, tree) {
            if (tree.status === 'cut' && tree.cut_angle) {
                // Convert cut_angle to mathematical angle (counterclockwise from east)
                const mathAngle = (90 - tree.cut_angle) * (Math.PI / 180);
                
                // Calculate end point
                const length = tree.height;
                const latLngPerMeter = 1 / 111111;
                
                const endLat = tree.lat + (length * Math.sin(mathAngle) * latLngPerMeter);
                const endLng = tree.lng + (length * Math.cos(mathAngle) * latLngPerMeter);
                
                // Draw line
                const line = L.polyline(
                    [[tree.lat, tree.lng], [endLat, endLng]],
                    {color: 'red', weight: 2}
                ).addTo(map);
                
                // Add arrow
                const arrowHead = L.polyline(
                    getArrowHead([tree.lat, tree.lng], [endLat, endLng]),
                    {color: 'red', weight: 2}
                ).addTo(map);
                
                return [line, arrowHead];
            }
            return null;
        }

        // Calculate arrow head points
        function getArrowHead(start, end) {
            const dx = end[1] - start[1];
            const dy = end[0] - start[0];
            const angle = Math.atan2(dy, dx);
            
            const arrowLength = 0.00005;
            const arrowAngle = Math.PI / 6;
            
            const x1 = end[1] - arrowLength * Math.cos(angle - arrowAngle);
            const y1 = end[0] - arrowLength * Math.sin(angle - arrowAngle);
            const x2 = end[1] - arrowLength * Math.cos(angle + arrowAngle);
            const y2 = end[0] - arrowLength * Math.sin(angle + arrowAngle);
            
            return [
                [end[0], end[1]],
                [y1, x1],
                [y2, x2]
            ];
        }

        // Store layers
        let blockLayers = {};
        let treeLayers = {};

        // Clear map
        function clearMap() {
            for (let block in blockLayers) {
                map.removeLayer(blockLayers[block]);
                delete blockLayers[block];
            }
            for (let block in treeLayers) {
                map.removeLayer(treeLayers[block]);
                delete treeLayers[block];
            }
        }

        // Add tree to map
        function addTreeToMap(tree, map) {
            const marker = L.marker([tree.lat, tree.lng], {
                icon: createTreeIcon(tree.status)
            });
            
            marker.bindPopup(`
                <b>Tree Number:</b> ${tree.treeNum}<br>
                <b>Block:</b> ${tree.block_x}, ${tree.block_y}<br>
                <b>Status:</b> ${tree.status}<br>
                <b>Height:</b> ${tree.height}m<br>
                <b>Diameter:</b> ${tree.diameter}cm
                ${tree.cut_angle ? '<br><b>Cut Angle:</b> ' + tree.cut_angle + 'Â°' : ''}
                ${tree.damage_stem ? '<br><b>Stem Damage Count:</b> ' + tree.damage_stem : ''}
                ${tree.damage_crown ? '<br><b>Crown Damage Count:</b> ' + tree.damage_crown : ''}
            `);
            
            if (tree.status === 'cut') {
                const fallingLine = drawFallingLine(map, tree);
                if (fallingLine) {
                    marker.fallingLine = fallingLine;
                }
            }
            
            return marker;
        }

        // Load trees
        function loadTrees() {
            const bounds = map.getBounds();
            const zoom = map.getZoom();
            
            fetch(`TreeDistribution.php?north=${bounds.getNorth()}&south=${bounds.getSouth()}&east=${bounds.getEast()}&west=${bounds.getWest()}`)
                .then(response => response.json())
                .then(data => {
                    clearMap();
                    
                    // Group by block
                    const blockGroups = {};
                    data.forEach(tree => {
                        const blockKey = `${tree.block_x},${tree.block_y}`;
                        if (!blockGroups[blockKey]) {
                            blockGroups[blockKey] = {
                                trees: [],
                                bounds: {
                                    minLat: Infinity,
                                    maxLat: -Infinity,
                                    minLng: Infinity,
                                    maxLng: -Infinity
                                }
                            };
                        }
                        
                        const lat = 3.97627092663759 + parseFloat(tree.relative_y);
                        const lng = 102.24896927028513 + parseFloat(tree.relative_x);
                        
                        blockGroups[blockKey].trees.push({...tree, lat, lng});
                        
                        // Update bounds
                        blockGroups[blockKey].bounds.minLat = Math.min(blockGroups[blockKey].bounds.minLat, lat);
                        blockGroups[blockKey].bounds.maxLat = Math.max(blockGroups[blockKey].bounds.maxLat, lat);
                        blockGroups[blockKey].bounds.minLng = Math.min(blockGroups[blockKey].bounds.minLng, lng);
                        blockGroups[blockKey].bounds.maxLng = Math.max(blockGroups[blockKey].bounds.maxLng, lng);
                    });

                    // Create blocks and add trees
                    Object.entries(blockGroups).forEach(([blockKey, block]) => {
                        const bounds = [
                            [block.bounds.minLat, block.bounds.minLng],
                            [block.bounds.maxLat, block.bounds.maxLng]
                        ];
                        
                        const rectangle = L.rectangle(bounds, {
                            color: '#000',
                            weight: 1,
                            fillOpacity: 0
                        });
                        
                        const center = [
                            (block.bounds.minLat + block.bounds.maxLat) / 2,
                            (block.bounds.minLng + block.bounds.maxLng) / 2
                        ];
                        
                        const label = L.marker(center, {
                            icon: L.divIcon({
                                className: 'block-label',
                                html: `Block ${blockKey}`
                            })
                        });

                        const treeGroup = L.layerGroup();
                        block.trees.forEach(tree => {
                            const treeMarker = addTreeToMap(tree, map);
                            treeGroup.addLayer(treeMarker);
                        });

                        blockLayers[blockKey] = L.layerGroup([rectangle, label]).addTo(map);
                        treeLayers[blockKey] = treeGroup.addTo(map);
                    });
                })
                .catch(error => console.error('Error fetching tree data:', error));
        }

        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // Set up event handlers
        const debouncedLoadTrees = debounce(loadTrees, 300);
        map.on('moveend', debouncedLoadTrees);
        map.on('zoomend', debouncedLoadTrees);
        
        // Initial setup
        updateBackgroundColor();
        loadTrees();
    </script>
</body>
</html>